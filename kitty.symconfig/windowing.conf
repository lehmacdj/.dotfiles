# OS Windows
# new windows
remember_window_size  no
# this size lets 80 columns fit in vim including space for line numbers etc.
initial_window_width  85c
initial_window_height 25c
inactive_text_alpha 0.5
# don't color active border differently
active_border_color none
# default
# inactive_border_color #cccccc
macos_titlebar_color background
# this is the default, but I'm still deciding how much I care about it
hide_window_decorations none
# We use the newer fullscreen animation that is prettier but a bit slower
macos_traditional_fullscreen no
macos_quit_when_last_window_closed yes
# Allow changing the background opacity at runtime
dynamic_background_opacity yes
background_opacity 1.0
map command+u remote_control set-background-opacity --toggle 0.8
map command+shift+u set_background_opacity default
map command+control+u set_background_opacity default
# theoretically I'd like to use this to get the background colors for some
# elements in neovim to be transparent, but annoyingly, these need to be set
# separately from the main background color in the keybinding, making it
# more practical to just not bother with it
# transparent_background_colors #173541 #163541 #073642

# tabs
tab_bar_style powerline
tab_powerline_style angled
tab_activity_symbol ‚ÅÇ
# this uses solarized base02/base1 for active fg/bg and base01/base02 for inactive
active_tab_foreground #073642
active_tab_background #93a1a1
inactive_tab_foreground #586e75
inactive_tab_background #073642
# slightly more muted scheme, not sure which I prefer yet
# this uses solarized base1/base02 for active fg/bg and base01/base02 for inactive
# active_tab_foreground #93a1a1
# active_tab_background #073642
# inactive_tab_foreground #586e75
# inactive_tab_background #002b37

# windows (i.e. splits)
# preserve cwd when opening new windows
# tabs don't need this and default bindings are fine
map command+d combine : goto_layout splits : launch --location=split --cwd=current --bias=50
map command+shift+d combine : goto_layout splits : launch --location=vsplit --cwd=current --bias=50
map command+control+d combine : goto_layout splits : launch --location=hsplit --cwd=current --bias=50
# like <C-z>, but open a new split so that the previous command can continue
# running, useful for builds/tests if you realize you want to do something
# while you're waiting on it, but don't care too much about seeing its output
map command+z launch --location=hsplit --cwd=current --bias=95

enabled_layouts splits,tall,vertical,grid,horizontal,fat,stack
# I pretty much want to stay in splits 100% of the time, thus complex binding
map command+control+shift+l next_layout
# temporarily maximize a single window
map command+enter toggle_layout stack
map command+shift+enter toggle_layout stack

# Move Between windows
# map <kind of want to map> focus_visible_window
map command+l neighboring_window right
map command+h neighboring_window left
map command+j neighboring_window down
map command+k neighboring_window up
# I type this a lot on accident, and would rather it do nothing
map command+shift+h nop

# Swap windows
map command+control+r layout_action rotate
map command+control+e swap_with_window
map command+control+l move_window right
map command+control+h move_window left
map command+control+j move_window down
map command+control+k move_window up

# modal mappings seem potentially nice for window management too
# https://sw.kovidgoyal.net/kitty/mapping/#modal-mappings

# Resizing
map command+. layout_action bias 80
map command+shift+. layout_action bias 50
map command+equal resize_window taller 4
map command+minus resize_window shorter 4
map command+] resize_window wider 4
map command+[ resize_window narrower 4
# The step size (in cell/line units) to use when resizing windows
# This only affects the resize UI and not the above mappings
window_resize_step_cells 4
window_resize_step_lines 4

map command+shift+0 toggle_maximized

# Closing windows
map command+w close_window
map command+shift+w close_tab
map command+control+w close_os_window
confirm_os_window_close -1
